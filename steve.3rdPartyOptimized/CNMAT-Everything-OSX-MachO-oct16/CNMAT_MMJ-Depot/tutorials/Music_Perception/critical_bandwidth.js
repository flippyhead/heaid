// Copyright John MacCallum 2006-07// All Rights Reserved/*Copyright (c) 2006-07.  The Regents of the University of California(Regents). All Rights Reserved.Permission to use, copy, modify, and distribute this software and itsdocumentation for educational, research, and not-for-profit purposes,without fee and without a signed licensing agreement, is herebygranted, provided that the above copyright notice, this paragraph andthe following two paragraphs appear in all copies, modifications, anddistributions.Contact The Office of Technology Licensing, UC Berkeley, 2150 ShattuckAvenue, Suite 510, Berkeley, CA 94720-1620, (510) 643-7201, for commerciallicensing opportunities.Written by John MacCallum, The Center for New Music and Audio Technologies,University of California, Berkeley.      IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,     SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST     PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS     DOCUMENTATION, EVEN IF REGENTS HAS BEEN ADVISED OF THE POSSIBILITY OF     SUCH DAMAGE.     REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS     FOR A PARTICULAR PURPOSE. THE SOFTWARE AND ACCOMPANYING     DOCUMENTATION, IF ANY, PROVIDED HEREUNDER IS PROVIDED "AS IS".     REGENTS HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,     ENHANCEMENTS, OR MODIFICATIONS.*/inlets = 2;outlets = 2;var mysketch = 0;var fixedFreq = 440.0;var movingFreq = 220.0;var fixedAmp = 1.;var movingAmp = 1.;var fixedAmps = new Array();var movingAmps = new Array();var numFixedPartials = 11; // plus the fundamental makes 12var numMovingPartials = 11; // plus the fundamental makes 12for (i = 0; i < numFixedPartials; i++) {	fixedAmps[i] = fixedAmp / (i + 2);}for (i = 0; i < numMovingPartials; i++) {	movingAmps[i] = movingAmp / (i + 2);	}var lowerFreqLimit = 200.var upperFreqLimit = 900;var infoBarHeight = 24; // pixlesvar complex_bool  = 0;var criticalBand_bool = 1;var newbg = 1;var newfg = 1;var bgColor = new Array(.1, .1, .4);//var fixedColor = new Array(.3, .3, .6, 1.);var fixedColor = new Array(.3, .3, 1., 1.);//var movingColor = new Array(.3, .3, 1., 1.);var movingColor = new Array(1., .5, .3, .5);//var erbColor = new Array(.3, .3, .6, 0.25);var erbColor = new Array(.3, .3, .8, 0.25);var infoColor = new Array(.3, .3, .6, 1.);sketch.default2d();sketch.fsaa=0;var scale = 0; // 0 = linear, 1 = log, 2 = ERBSfunction reset() {	init();}function domain(x1, x2) {	lowerFreqLimit = x1;	upperFreqLimit = x2;	newbg = 1;	draw();}function ftox(f,a){	switch (scale) {		case 0: // linear			return ((f-lowerFreqLimit)*2.0*a/(upperFreqLimit - lowerFreqLimit))-a;			break;		case 1: // log			return ((Math.log(f-lowerFreqLimit) / Math.log(2))*2.0*a/(Math.log(upperFreqLimit - lowerFreqLimit) / Math.log(2)))-a;			break;		case 2: // ERBS			return ((erbs(f)-erbs(lowerFreqLimit))*2.0*a/(erbs(upperFreqLimit) - erbs(lowerFreqLimit)))-a;			break;	}}function atoy(amp) {	//return (2 * amp) - 1.;	return ((1. - infoBarLocation()) * amp) + infoBarLocation();}function msg_float(f) {	if (inlet == 0)		setMovingFreq(f);	if (inlet == 1)		setFixedFreq(f);}function msg_int(i) {	if (inlet == 0)		setMovingFreq(i);	if (inlet == 1)		setFixedFreq(i);}function outputFixed() {	if (complex_bool) {		var ar = new Array();		ar[0] = fixedFreq;		ar[1] = fixedAmp;		for (i = 1; i < numFixedPartials + 1; i++) {			ar[i * 2] = fixedFreq * (i + 1);			ar[(i * 2) + 1] = fixedAmps[i - 1];		}		outlet(1, ar);		post(ar, "\n");		return;	}	outlet(1, fixedFreq, fixedAmp);}function outputMoving() {	if (complex_bool) {		var ar = new Array();		ar[0] = movingFreq;		ar[1] = movingAmp;		for (i = 1; i < numMovingPartials + 1; i++) {			ar[i * 2] = movingFreq * (i + 1);			ar[(i * 2) + 1] = movingAmps[i - 1];		}		outlet(0, ar);		return;	}	outlet(0, movingFreq, movingAmp);}function list(a) {	var a = arrayfromargs(messagename, arguments);		if (inlet == 0) {		if (a.length == 2) {			// assume freq, amp for fundamental			setMovingFreq(a[0]);			setMovingAmp(a[1]);		}		if (a.length > 2) {			//assume the first value is for the fundamental.			movingAmp = a[0];			for (i = 1; i < a.length; i++) {				movingAmps[i - 1] = a[i];			}		}		outputMoving();	}		if (inlet == 1) {		if (a.length == 2) {			// assume freq, amp for fundamental			setFixedFreq(a[0]);			setFixedAmp(a[1]);		}		if (a.length > 2) {			//assume the first value is for the fundamental.			fixedAmp = a[0];			for (i = 1; i < a.length; i++) {				fixedAmps[i - 1] = a[i];			}		}		outputFixed();	}	newbg = 1;	draw();		}function setFixedFreq(f){	if ( f + (erb(f) / 2) > upperFreqLimit ) {		fixedFreq = upperFreqLimit - (erb(f) / 2);		newbg = 1;		draw();		return;	}	if ( f - (erb(f) / 2) < lowerFreqLimit ) {		fixedFreq = lowerFreqLimit + (erb(f) / 2);		newbg = 1;		draw();		return;	}	fixedFreq = f;	newbg = 1;	draw();	outputFixed();	//outlet(1, fixedFreq, fixedAmp);}function setMovingFreq(f){	if ( f  > upperFreqLimit ) {		movingFreq = upperFreqLimit;		newbg = 1;		draw();		return;	}	if ( f < lowerFreqLimit ) {		movingFreq = lowerFreqLimit;		newbg = 1;		draw();		return;	}	movingFreq = f;	newbg = 1;	draw();	outputMoving();	//outlet(0, movingFreq, movingAmp);}function setFixedAmp(a) {	var a1, a2;	a1 = fixedAmp;	a2 = a;	if(a > 1.)		fixedAmp = 1.;	else if(a < 0.)		fixedAmp = 0.;	else		fixedAmp = a;	scaleFixedAmps(a1 / a2);		newbg = 1;	draw();	outputFixed();	//outlet(0, fixedFreq, fixedAmp);}function setMovingAmp(a) {	var a1, a2;	a1 = movingAmp;	a2 = a;	if(a > 1.)		movingAmp = 1.;	else if(a < 0.)		movingAmp = 0.;	else		movingAmp = a;		scaleMovingAmps(a1 / a2);	newbg = 1;	draw();	outputMoving();	//outlet(0, movingFreq, movingAmp);}function setFixedAmps() {	for (i = 0; i < numFixedPartials; i++) {		fixedAmps[i] = fixedAmp / (i + 2);	}	newbg = 1;	draw();	outputFixed();	//outlet(0, fixedFreq, fixedAmp);}function setMovingAmps() {	for (i = 0; i < numMovingPartials; i++) {		movingAmps[i] = movingAmp / (i + 2);		}	newbg = 1;	draw();	outputMoving();	//outlet(0, movingFreq, movingAmp);}function scaleFixedAmps(a) {	for (i = 0; i < numFixedPartials; i++) {		fixedAmps[i] = (fixedAmps[i] / a);	}}function scaleMovingAmps(a) {	for (i = 0; i < numMovingPartials; i++) {		movingAmps[i] = (movingAmps[i] / a);	}}function complex(i) {	complex_bool = i;	newbg = 1;	draw();	outputFixed();	outputMoving();}function criticalBand(i) {	criticalBand_bool = i;	newbg = 1;	draw();}var mysketch;function mydraw(){		if(newbg==1 || newfg==1) {		if(!mysketch) {		 	var sk = sketch.size;			mysketch= new Sketch(sk[0],sk[1]);			mysketch.default2d();			mysketch.fsaa=0;			mysketch.aspect = sk[0]/sk[1];		}	}	if(newbg==1) {		mysketch.glclearcolor(bgColor);		mysketch.glclear();		// draw info line.		mysketch.glcolor(infoColor);		mysketch.moveto(-mysketch.aspect, infoBarLocation());		mysketch.lineto(mysketch.aspect, infoBarLocation());		// draw fixed freq.		mysketch.glcolor(fixedColor);		mysketch.moveto(ftox(fixedFreq, mysketch.aspect), infoBarLocation());		mysketch.lineto(ftox(fixedFreq, mysketch.aspect), atoy(fixedAmp));				// draw moving freq.		mysketch.glcolor(movingColor);		mysketch.moveto(ftox(movingFreq, mysketch.aspect), infoBarLocation());		mysketch.lineto(ftox(movingFreq, mysketch.aspect), atoy(movingAmp));		// draw critical band		if(criticalBand_bool) {			mysketch.glcolor(erbColor);			var oneHalfCB = erb(fixedFreq) / 2;							mysketch.quad(ftox(fixedFreq - oneHalfCB, mysketch.aspect), infoBarLocation(), 0, ftox(fixedFreq - oneHalfCB, mysketch.aspect), atoy(fixedAmp), 0, ftox(fixedFreq + oneHalfCB, mysketch.aspect), atoy(fixedAmp), 0, ftox(fixedFreq + oneHalfCB, mysketch.aspect), infoBarLocation(), 0);		}		if (complex_bool == 1) {			for (i = 0; i < numMovingPartials; i++) {				mysketch.glcolor(fixedColor);				mysketch.moveto(ftox(fixedFreq * (i + 2), mysketch.aspect), infoBarLocation());				mysketch.lineto(ftox(fixedFreq * (i + 2), mysketch.aspect), atoy(fixedAmps[i]));				post(i, fixedAmps[i], "\n");				mysketch.glcolor(movingColor);				mysketch.moveto(ftox(movingFreq * (i + 2), mysketch.aspect), infoBarLocation());				mysketch.lineto(ftox(movingFreq * (i + 2), mysketch.aspect), atoy(movingAmps[i]));								if (criticalBand_bool) {					mysketch.glcolor(erbColor);					var oneHalfCB = erb(fixedFreq * (i + 2)) / 2;									mysketch.quad(ftox((fixedFreq * (i + 2)) - oneHalfCB, mysketch.aspect), infoBarLocation(), 0, ftox((fixedFreq * (i + 2)) - oneHalfCB, mysketch.aspect), atoy(fixedAmps[i]), 0, ftox((fixedFreq * (i + 2)) + oneHalfCB, mysketch.aspect), atoy(fixedAmps[i]), 0, ftox((fixedFreq * (i + 2)) + oneHalfCB, mysketch.aspect), infoBarLocation(), 0);				}			}		}				newbg = 0;	}		sketch.glclearcolor(0,0,0);	sketch.glclear();	sketch.glcolor(1,1,1,1);		sketch.copypixels(mysketch);	var sk = sketch.size;	sketch.aspect = sk[0]/sk[1];		// draw info text at the bottom of the window.	sketch.fontsize(9);		// fixed freq	sketch.glcolor(fixedColor);	sketch.textalign("left", "bottom");	sketch.moveto(-sketch.aspect, ((3 / sketch.size[1]) * 2.0) - 1);	sketch.text(" Fixed Frequency: "+fixedFreq.toFixed(2)+" ("+Notename(fixedFreq)+")");	// moving freq	sketch.glcolor(movingColor);	sketch.textalign("left", "bottom");	sketch.moveto(-sketch.aspect, ((14 / sketch.size[1]) * 2.0) - 1);	sketch.text(" Moving Frequency: "+movingFreq.toFixed(2)+" ("+Notename(movingFreq)+")");	// difference	sketch.glcolor(infoColor);	sketch.textalign("left", "bottom");	sketch.moveto(0, ((14 / sketch.size[1]) * 2.0) - 1);	sketch.text(" Beat Frequency: "+Math.abs(movingFreq - fixedFreq).toFixed(2)+"Hz ");}function infoBarLocation() {	return ((infoBarHeight / sketch.size[1]) * 2.0) - 1;}function erb(f) {	return (0.108 * f) + 24.7;	// B. C. J. Moore and B. R. Glasberg, ``A revision of Zwicker's loudness  model,'' Acta Acustica, vol. 82, pp. 335-345, 1996.		// Taken from http://www-ccrma.stanford.edu/~jos/bbt/Equivalent_Rectangular_Bandwidth.html}function erbs(f) {	return 21.4 * (Math.log(0.00437 * f + 1) / Math.log(Math.LN10));	// B. C. J. Moore and B. R. Glasberg, ``A revision of Zwicker's loudness  model,'' Acta Acustica, vol. 82, pp. 335-345, 1996.		// Taken from http://www-ccrma.stanford.edu/~jos/bbt/Equivalent_Rectangular_Bandwidth.html}function calcInterval(f, i){	return f * (Math.pow(Math.pow(2, 1/12), i));}function setScale(s) {	//post("scale: ", s, "\n");	switch(s) {		case "linear":			scale = 0;			break;		case "log":			scale = 1;			break;		case "ERB":			scale = 2;			break;	}	newbg = 1;	draw();}function draw() {	mydraw();	refresh();}function onresize() {	mysketch = null;	newbg = 1;	draw();}// Thanks to PF Baisnee for the original C code base this is derived fromconst A440=440.0;const C261=261.6255661;const SEMITONE=1.059463094;const OCTAVESIZE=12;const OCTAVEBASE=3;/* ln(SEMITONE) */const SEMIFAC=0.057762265046662;const AASMIDINOTE=69;const CASMIDINOTE=60;const notenames= ["c","c#","d","d#","e","f","f#","g","g#","a","a#","b"];const frenchnotenames= new Array("do","do#","re","re#","mi","fa","fa#","sol","sol#","la","la#","si");function nearestnote(f){   var i;	i = Math.log(f/C261)/Math.log(SEMITONE)+1.5;  // this was set to 0.5 in Adrian Freed's orig. code--bug?   return new Array(   	(Math.floor(i)+OCTAVESIZE*OCTAVEBASE-1)%OCTAVESIZE, //note       Math.floor((Math.floor(i)+OCTAVESIZE*OCTAVEBASE-1)/OCTAVESIZE), //octave    i+CASMIDINOTE, //midi note    Math.floor((i%1)*100));//cents }var ns="American";var notenamestyles= new Array("American", "Solfege", "Columbia", "FractionalMIDI");function notenamestyle(n){//	if(n in notenamestyles)	{ns =n;		draw();	}}function Notename(f){	const style =ns;if(f<=0)	return "";	const nn = nearestnote(f);	const note = nn[0];	const octave = nn[1];	const midi =nn[2];	const cents = nn[3];		   if(style=="Solfege")	    	return frenchnotenames[note]+octave;	    else if(style=="American")	    	return notenames[note]+octave;	    else if(style=="Columbia")	    	return (octave+5+note/100.0).toFixed(3);	    else if(style=="FractionalMIDI")	    	return "m"+midi.toFixed(3);	}function init() {	var bgColor = new Array(.1, .1, .4);	//var fixedColor = new Array(.3, .3, .6, 1.);	var fixedColor = new Array(.3, .3, 1., 1.);	//var movingColor = new Array(.3, .3, 1., 1.);	var movingColor = new Array(1., .5, .3, .5);	//var erbColor = new Array(.3, .3, .6, 0.25);	var erbColor = new Array(.3, .3, .8, 0.25);	var infoColor = new Array(.3, .3, .6, 1.);		fixedFreq = 440.0;	movingFreq = 220.0;	fixedAmp = 1.;	movingAmp = 1.;	fixedAmps = new Array();	movingAmps = new Array();	numFixedPartials = 11; // plus the fundamental makes 12	numMovingPartials = 11; // plus the fundamental makes 12	for (i = 0; i < numFixedPartials; i++) {		fixedAmps[i] = fixedAmp / (i + 2);	}		for (i = 0; i < numMovingPartials; i++) {		movingAmps[i] = movingAmp / (i + 2);		}	lowerFreqLimit = 200.	upperFreqLimit = 900;	infoBarHeight = 24; // pixles	complex_bool  = 0;	criticalBand_bool = 1;	newbg = 1;	outputFixed();	outputMoving();	draw();}function interval(s) {	switch (s) {		case "Unison":			movingFreq = fixedFreq;			break;		case "Octave Above":			movingFreq = fixedFreq * 2;			break;		case "Octave Below":			movingFreq = fixedFreq * .5;			break;		case "Minor Second Above":			movingFreq = calcInterval(fixedFreq, 1);			break;		case "Major Second Above":			movingFreq = calcInterval(fixedFreq, 2);			break;		case "Minor Third Above":			movingFreq = calcInterval(fixedFreq, 3);			break;		case "Major Third Above":			movingFreq = calcInterval(fixedFreq, 4);			break;		case "Perfect Fourth Above":			movingFreq = calcInterval(fixedFreq, 5);			break;		case "Tritone Above":			movingFreq = calcInterval(fixedFreq, 6);			break;		case "Perfect Fifth Above":			movingFreq = calcInterval(fixedFreq, 7);			break;		case "Minor Sixth Above":			movingFreq = calcInterval(fixedFreq, 8);			break;		case "Major Sixth Above":			movingFreq = calcInterval(fixedFreq, 9);			break;		case "Minor Seventh Above":			movingFreq = calcInterval(fixedFreq, 10);			break;		case "Major Seventh Above":			movingFreq = calcInterval(fixedFreq, 11);			break;				case "Minor Second Below":			movingFreq = calcInterval(fixedFreq, -1);			break;		case "Major Second Below":			movingFreq = calcInterval(fixedFreq, -2);			break;		case "Minor Third Below":			movingFreq = calcInterval(fixedFreq, -3);			break;		case "Major Third Below":			movingFreq = calcInterval(fixedFreq, -4);			break;		case "Perfect Fourth Below":			movingFreq = calcInterval(fixedFreq, -5);			break;		case "Tritone Below":			movingFreq = calcInterval(fixedFreq, -6);			break;		case "Perfect Fifth Below":			movingFreq = calcInterval(fixedFreq, -7);			break;		case "Minor Sixth Below":			movingFreq = calcInterval(fixedFreq, -8);			break;		case "Major Sixth Below":			movingFreq = calcInterval(fixedFreq, -9);			break;		case "Minor Seventh Below":			movingFreq = calcInterval(fixedFreq, -10);			break;		case "Major Seventh Below":			movingFreq = calcInterval(fixedFreq, -11);			break;	}	newbg = 1;	draw();	outputFixed();	outputMoving();}draw();