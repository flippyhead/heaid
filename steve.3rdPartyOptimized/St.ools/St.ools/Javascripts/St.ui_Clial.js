/*3d dialarguments: fgred fggreen fgblue bgred bggreen bgblue dialred dialgreen dialblue mode*/sketch.ortho3d(); //like default3d but uses orthographic projectionvar val = 0.5;var vbrgb = [1.,1.,1.];var vfrgb = [0.9,0.1,0.1];var vrgb2 = [0.7,0.7,0.7];var vsat =  1.;var vlum = 0.5;var vhue = 0.5;var vfactor = 1.;var last_x = 0;var last_y = 0;var outval = 0;outlets = 2;// process argumentsif (jsarguments.length>1)	vfactor = jsarguments[1];if (jsarguments.length>2)	vlum = jsarguments[2];if (jsarguments.length>3)	vsat = jsarguments[3];hsl2rgb()draw();function draw(){	var theta;	var width = box.rect[2] - box.rect[0];	with (sketch) {		glenable("depth_test");					shapeslice(64,8);		glcullface("back");				// wireframe off		glpolygonmode("front","fill");					glpolygonmode("back","fill");					// erase background		glclearcolor(vbrgb);		glclear();					// fill bg sphere					glcolor(vrgb2);		moveto(0,0,0);		sphere(0.9,0,360,0,90);								// fill fg arc		glclear("depth");					glcolor(vfrgb);		sphere(0.9,-180,180,0,90);								// draw arc outline		gldisable("depth_test");					glenable("line_smooth");					shapeslice(80,1);		glcolor(0,0,0,1);		framecircle(0.9,-90-val*360,-90);			glcolor(0,0,0,1);		moveto(0,0);		lineto(0,-0.9);		moveto(0,0);		theta = (0.75-val)*2*Math.PI;		lineto(0.9*Math.cos(theta),0.9*Math.sin(theta));			}}function hue2rgb( v1, v2, vH )             //Function Hue_2_RGB{	if ( vH < 0 ) vH += 1	if ( vH > 1 ) vH -= 1	if ( ( 6. * vH ) < 1 ) return ( v1 + ( v2 - v1 ) * 6. * vH )	if ( ( 2. * vH ) < 1 ) return ( v2 )	if ( ( 3. * vH ) < 2 ) return ( v1 + ( v2 - v1 ) * ( (0.666667) - vH ) * 6. )	return ( v1 )}function hsl2rgb(){	var var_1 = 0.;	var var_2 = 0.;	var lum = 0.5;	if ( vsat == 0 )	{		vfrgb[0] = vlum                      		vfrgb[1] = vlum 		vfrgb[2] = vlum	}	else	{		if (vhue > 0.9) lum = vlum - 2*(vhue - 0.9)		else lum = vlum		if ( lum < 0.5 ) var_2 = lum * ( 1. + vsat )		else           var_2 = ( lum + vsat ) - ( vsat * lum )		var_1 = 2. * lum - var_2		vfrgb[0] = hue2rgb( var_1, var_2, vhue + (0.333333) )		vfrgb[1] = hue2rgb( var_1, var_2, vhue )		vfrgb[2] = hue2rgb( var_1, var_2, vhue - ( 0.333333) )	}}function bang(){	outval = val*vfactor;	vhue = val;	hsl2rgb();	draw();	refresh();	outlet(0,outval);}function msg_float(v){	val = Math.min(Math.max(0.,v),1.);	notifyclients();	bang();}function msg_int(v){	msg_float(v/127.);}function set(v){	val = Math.min(Math.max(0.,v),1.);	draw();	refresh();}function scale(v){	vfactor = v;}function fsaa(v){	sketch.fsaa = v;	bang();}function sat(v){	vsat = v;	bang()	refresh();}function lum(v){	vlum = v;	bang()	refresh();}function brgb(r,g,b){	vbrgb[0] = r/255.;	vbrgb[1] = g/255.;	vbrgb[2] = b/255.;	draw();	refresh();}function frgb(r,g,b){	vrgb2[0] = r/255.;	vrgb2[1] = g/255.;	vrgb2[2] = b/255.;	draw();	refresh();}function setvalueof(v){	msg_float(v);}function getvalueof(){	bang()	return outval;}function onresize(w,h){	draw();	refresh();}onresize.local = 1; //privatefunction onclick(x,y,but,cmd,shift,capslock,option,ctrl){	// cache mouse position for tracking delta movements	last_x = x;	last_y = y;}onclick.local = 1; //private. could be left public to permit "synthetic" eventsfunction ondrag(x,y,but,cmd,shift,capslock,option,ctrl){	var f,dy;		// calculate delta movements	dy = y - last_y;	if (shift) { 		// fine tune if shift key is down		f = val - dy*0.001; 	} else {		f = val - dy*0.01;	}	msg_float(f); //set new value with clipping + refresh	// cache mouse position for tracking delta movements	last_x = x;	last_y = y;}ondrag.local = 1; //private. could be left public to permit "synthetic" events