#include "ext.h"#include "z_dsp.h"#include <stdlib.h>#include "stdio.h"void *pulser_class;#define FUNC_LEN (16384)#define FUNC_LEN_OVER2 (8192)#define MAX_COMPONENTS (256)// improve to allow varying number of components (within boundaries)typedef struct _pulser{  t_pxobject x_obj;  int components;  float global_gain;  float *wavetab; // holds sine wave	float *rectwavetab; // holds rectified sine wave  double *phases;  float *hscale; // scalar for each harmonic  float frequency;  float pulsewidth;  float si_fac;  short mute;  short connected[4];  float sr;  short oldschool; // flag to use older (incorrect) scaling method} t_pulser;void *pulser_new(t_symbol *s, int argc, t_atom *argv);t_int *pulser_perform(t_int *w);void pulser_dsp(t_pulser *x, t_signal **sp, short *count);void pulser_assist(t_pulser *x, void *b, long m, long a, char *s);void pulser_mute(t_pulser *x, double toggle);void pulser_oldschool(t_pulser *x, double toggle);void pulser_harmonics(t_pulser *x, double c);void pulser_float(t_pulser *x, double f);void pulser_free(t_pulser *x);void main(void){  setup((t_messlist **)&pulser_class,(method) pulser_new, (method)pulser_free,   (short)sizeof(t_pulser), 0L, A_GIMME, 0);  addmess((method)pulser_dsp, "dsp", A_CANT, 0);  addmess((method)pulser_assist,"assist",A_CANT,0);  addmess((method)pulser_mute,"mute",A_FLOAT,0);  addmess((method)pulser_oldschool,"oldschool",A_FLOAT,0);  addmess((method)pulser_harmonics,"harmonics",A_FLOAT,0);  addfloat((method)pulser_float);  dsp_initclass();  post("pulser~ by Eric Lyon");}void pulser_mute(t_pulser *x, double toggle){	x->mute = (short)toggle;}void pulser_oldschool(t_pulser *x, double toggle){	x->oldschool = (short) toggle;}void pulser_assist (t_pulser *x, void *b, long msg, long arg, char *dst){  if (msg==1) {    switch (arg) {    case 0:      sprintf(dst,"(signal/float) Frequency");      break;    case 1:      sprintf(dst,"(signal/float) Pulse Width");      break;    }  } else if (msg==2) {    sprintf(dst,"(signal) Output");  }}void pulser_harmonics(t_pulser *x, double c){	int i;	double *phases = x->phases;		if(c < 2 || c > MAX_COMPONENTS){		error("harmonic count out of bounds");		return;	}	x->components = c;	x->global_gain = 1.0 / (float) x->components ;	for(i = 0; i < MAX_COMPONENTS; i++){		phases[i] = 0.0;	}}void pulser_float(t_pulser *x, double f){int inlet = ((t_pxobject*)x)->z_in;	if (inlet == 0)	{		x->frequency = f;	} 	else if (inlet == 1 )	{		x->pulsewidth = f;	}}void pulser_free(t_pulser *x){	dsp_free((t_pxobject *)x);	free(x->phases);	free(x->wavetab);	free(x->hscale);	free( x->rectwavetab );}void *pulser_new(t_symbol *s, int argc, t_atom *argv){  t_pulser *x = (t_pulser *)newobject(pulser_class);  float srate;  int i;  dsp_setup((t_pxobject *)x,2);  outlet_new((t_pxobject *)x, "signal");  x->sr = sys_getsr();  if(!x->sr){    error("zero sampling rate, setting to 44100");    x->sr = 44100;  }  x->mute = 0;  x->components = 8;  x->frequency = 440.0;  x->pulsewidth = 0.5;    if( argc > 0 )    x->frequency = atom_getfloatarg(0,argc,argv);  if( argc > 1 )    x->components = atom_getfloatarg(1,argc,argv);			  x->si_fac = ((float)FUNC_LEN/x->sr) ;    if(x->components <= 0 || x->components > MAX_COMPONENTS){  	error("%d is an illegal number of components, setting to 8",x->components );  	x->components = 8;  }  x->global_gain = 1.0 / (float) x->components ;  x->phases = (double *) calloc(MAX_COMPONENTS, sizeof(double) );  x->hscale = (float *) calloc(MAX_COMPONENTS, sizeof(float) );  x->wavetab = (float *) calloc(FUNC_LEN, sizeof(float) );	x->rectwavetab = (float *) calloc(FUNC_LEN, sizeof(float) );		for(i = 0; i < MAX_COMPONENTS; i++){		x->hscale[i] = 1.0 / (float)(i + 1);	}		  for(i = 0 ; i < FUNC_LEN; i++) {    x->wavetab[i] = sin(TWOPI * ((float)i/(float) FUNC_LEN)) ;    x->rectwavetab[i] = fabs( x->wavetab[i] );  }  return (x);}t_int *pulser_perform(t_int *w){  int i,j;  float mygain ;  float gain;  float phs;  float incr;  float outsamp;  int lookdex;  t_pulser *x = (t_pulser *) (w[1]);  t_float *frequency_vec = (t_float *)(w[2]);  t_float *pulsewidth_vec = (t_float *)(w[3]);  t_float *out = (t_float *)(w[4]);  t_int n = w[5];	  float *wavetab = x->wavetab;  float *rectwavetab = x->rectwavetab;  float si_fac = x->si_fac;  double *phases = x->phases;  int components = x->components;  float global_gain = x->global_gain;  float pulsewidth = x->pulsewidth;  float frequency = x->frequency;  short *connected = x->connected;  float *hscale = x->hscale;    if( x->mute )  {  	while( n-- ){  		*out++ = 0.0;  	}  	return (w+6);  }    incr = frequency * si_fac;  if(x->oldschool) {	  while (n--) { 	    if( connected[1] ){	    	pulsewidth = *pulsewidth_vec++;	    }	    if( pulsewidth < 0 )	      pulsewidth = 0;	    if( pulsewidth > 1 )	      pulsewidth = 1;	    	    if( connected[0] ){	      incr = *frequency_vec++ * si_fac ;	    }	 	    outsamp = 0;	    	    for( i = 0, j = 1; i < components; i++, j++){	      lookdex = (float)FUNC_LEN_OVER2 * pulsewidth * (float)j;	 	      while( lookdex >= FUNC_LEN ){					lookdex -= FUNC_LEN;			  }	      gain = wavetab[ lookdex ]; // added gain factor	      phases[i] += incr * (float) j;	      while( phases[i] < 0.0 ) {					phases[i] += FUNC_LEN;	      }	      while( phases[i] >= FUNC_LEN ){					phases[i] -= FUNC_LEN;	      }	      outsamp += gain * wavetab[ (int) phases[i] ];				    }	    *out++ =  outsamp * global_gain; 	  }  } else {	  while (n--) { 	    if( connected[1] ){	    	pulsewidth = *pulsewidth_vec++;	    	// post("pw %f",pulsewidth);	    }	    if( pulsewidth < 0 )	      pulsewidth = 0;	    if( pulsewidth > 1 )	      pulsewidth = 1;	    	    if( connected[0] ){	      incr = *frequency_vec++ * si_fac ;	    }	 	    outsamp = 0;	    	    for( i = 0, j = 1; i < components; i++, j++){	      lookdex = (float)FUNC_LEN_OVER2 * pulsewidth * (float)j;	 	      while( lookdex >= FUNC_LEN ){					lookdex -= FUNC_LEN;			  }	      gain = hscale[i] * rectwavetab[ lookdex ]; // added gain factor	      phases[i] += incr * (float) j;	      while( phases[i] < 0.0 ) {					phases[i] += FUNC_LEN;	      }	      while( phases[i] >= FUNC_LEN ){					phases[i] -= FUNC_LEN;	      }	      outsamp += gain * wavetab[ (int) phases[i] ];				    }	    *out++ =  outsamp * global_gain; 	  }  }  return (w+6);}		void pulser_dsp(t_pulser *x, t_signal **sp, short *count){  long i;	if(!sp[0]->s_sr){		error("zero sampling rate");		return;	}//	memset((char *)x->phases, 0, MAX_COMPONENTS * sizeof(float) ); // reset phases	for(i = 0; i < MAX_COMPONENTS; i++){		x->phases[i] = 0.0;	}  if(x->sr != sp[0]->s_sr){//  post("sr reset");  	x->sr = sp[0]->s_sr;  	x->si_fac = ((float)FUNC_LEN/x->sr);  	/* for(i=0;i<MAX_COMPONENTS;i++){  		x->phases[i] = 0.0;  	}*/  }  for( i = 0; i < 2; i++){//    post("connection %d: %d",i,count[i]);  	x->connected[i] = count[i];  }  dsp_add(pulser_perform, 5, x, sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[0]->s_n);}